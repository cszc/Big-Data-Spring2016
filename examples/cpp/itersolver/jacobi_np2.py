#!/usr/bin/python

# CMSC 12300 - Computer Science with Applications 3
# Borja Sotomayor, 2013

"""
Solves a system of linear equations using the
Jacobi method.

Unlike jacobi.py and jacobi_np.py, this implementation
uses the matrix definition of the Jacobi method,
which better enables NumPy to work its magic.

The command takes a single parameter:

    jacobi_np2.py FILE

FILE: A file containing the system of linear
equations (as generated by gen_lineq.py)
"""

import sys
import numpy as np

fname = sys.argv[1]
f = open(fname)

numEq, numVar = f.readline().strip().split()

numEq = int(numEq)
numVar = int(numVar)

assert(numEq == numVar)

N = numEq

A = np.empty((N,N))
b = np.empty((N,))

for i, line in enumerate(f):
    nums = [float(x) for x in line.strip().split()]
    for j in range(N):
        A[i,j] = nums[j]
    b[i] = nums[-1]

iters=0
converged=False

solution=np.zeros((N,))

while not converged and iters < 10000:
    prevsolution = solution
    solution = np.empty((N,))

    D = np.diag(A)
    R = A - np.diagflat(D)
    solution = (b - np.dot(R,prevsolution)) / D

    iters += 1

    # Has it converged?
    toobig=False
    for prev, cur in zip(prevsolution, solution):
        if abs(prev-cur) >= 0.001:
            toobig=True
    if not toobig:
        converged = True

if not converged:
    print "Did not converge"
else:
    b_sol = [] 
    for i in range(N):
        v = 0.0
        for j in range(N):
            v += solution[j]*A[i,j]
        b_sol.append(v)

    for i in range(N):
        print "x_%i = %.3f" % (i, solution[i])

    print

    for i in range(N):
        print "b_%i = %.3f (%.3f)" % (i, b_sol[i], b[i])

    print "Solved in %i iterations" % iters
